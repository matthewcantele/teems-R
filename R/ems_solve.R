#' Configure and solve model
#'
#' @description `ems_solve()` solves the constrained optimization
#'   problem according to a wide range of runtime configuration
#'   options. In order to solve, a `teems` Docker image must be
#'   prebuilt according to these specifications. Singularity,
#'   accuracy, and error checks are carried out following a successful
#'   run.
#'
#' @param cmf_path Character length 1 (default is `NULL`), path to the
#'   cmf file generated by [`teems_deploy()`] or created via an
#'   "in-situ" run with [`ems_solve()`].
#' @param n_tasks Integer length 1 (default is `1L`), number of tasks
#'   to run in parallel. Must be `1L` if `"matrix_method"` == "LU".
#' @param n_subintervals Integer length 1 (default is `1L`), number of
#'   subintervals for the applied shock. More subintervals may
#'   alleviate accuracy issues stemming from large shock magnitudes.
#' @param matrix_method Character of length 1, matrix solution method
#'   (default is `"LU"`). Choices:
#'   * `"LU"`: Standard LU decomposition, the most robust and
#'   potentially slowest for a large model. `"n_tasks"` must be `1L`
#'   if `"matrix_method"` == "LU". For use with both static and
#'   dynamic models.
#'   * `"DBBD"`: Doubly bordered block diagonal, parallel solution
#'   method for static models. Potentially faster than `"LU"` although
#'   less robust.
#'   * `"SBBD"`: Singly bordered block diagonal, parallel solution
#'   method for intertemporal models. Potentially faster than `"LU"`
#'   although less robust.
#'   * `"NDBBD"`: Nested doubly bordered block diagonal, parallel
#'   solution method for large intertemporal models with many
#'   timesteps.
#' @param solution_method The solution method to be used, default is
#'   the "one-step" `"Johansen"`. Choices:
#'   * `"Johansen"`: The Johansen method is fast however it should
#'   only be used as a rough approximation due to handling of
#'   nonlinear equations. See:
#'   https://www.copsmodels.com/gpmanual.htm#gpd1.2.13
#'   * `"mod_midpoint"`: The modified midpoint method
#'   performs multiple passes. See:
#'   https://www.copsmodels.com/gpmanual.htm#gpd3.12.2
#' @param steps Integer length 3 (default is `c(2L, 4L, 8L)`). A
#'   vector of steps for the modified midpoint method, must be all odd
#'   or all even and length 3. Additional steps may improve accuracy
#'   for some model runs.
#' @param laA Integer length 1 (default is `300L`). The laA memory
#'   parameter for solver pertaining to matrix methods `"LU"` and
#'   `"SBBD"`. Value is in percentages. Increase gradually if prompted
#'   via "Error return from MA48B/BD because LA is ..."
#' @param laD Integer length 1 (default is `200L`). The laD memory
#'   parameter for solver pertaining to matrix methods `"DBBD"` and
#'   `"NDBBD"`. Value is in percentages. Increase gradually if
#'   prompted via "Error return from MA48B/BD because LA is ..."
#' @param laDi Integer length 1 (default is `500L`). The laDi memory
#'   parameter for solver pertaining to matrix method `"NDBBD"`. Value
#' is in percentages. Increase gradually if prompted via "Error return
#' from MA48B/BD because LA is ..."
#' @param terminal_run Logical length 1 (default is `FALSE`). When
#'   `TRUE`, the function is exited without running the solver. This
#'   allows the user to close any R IDE or other programs prior to
#' running from the terminal.
#' @param suppress_outputs Logical length 1 (default is `FALSE`).
#'   When `TRUE` solver outputs are not automatically converted
#'   into structured data with [`ems_compose`].
#' @param ... A named list of input files necessary for an
#'   "in-situ" model run. Names must correspond to "File"
#'   statements within the model Tablo file. Elements correspond
#'   to file paths where these files are found. No checks or
#'   modifications are conducted on input files used in this
#'   manner. This mode does not support partial provision of
#'   input file -- all model defined input files as well as
#'   `"tab_file"`, `"closure_file"`, and `"shock_file"` are
#'   required for in-situ model runs.
#' 
#'
#' @seealso [`ems_compose()`] for retrieving model results.
#'
#' @examples
#' \dontrun{
#' # sample static model setup
#' v6.2_cmf_path <- teems_deploy(model_config = v6.2_model_config,
#'                              base_config = v6.2_base_config,
#'                              param_config = v6.2_param_config,
#'                              set_config = v6.2_set_config,
#'                              closure_config = v6.2_closure_config)
#'
#' # The most simple solution is an LU Johansen with a single task:
#' ems_solve(cmf_path = v6.2_cmf_path,
#'             matrix_method = "LU",
#'             solution_method = "Johansen")
#'
#' # For most model runs however the modified midpoint method is
#' # preferred. If variable accuracy is unacceptable, increasing the
#' # number of subintervals and/or steps may improve accuracy. We
#' # recommend isolating any improvements through slight modifications
#' # to either subintervals or steps.
#'
#' # Standard model run with LU and modified midpoint:
#' ems_solve(cmf_path = v6.2_cmf_path,
#'             matrix_method = "LU",
#'             n_subintervals = 2,
#'             solution_method = "mod_midpoint",
#'             steps = c(2, 4, 8))
#'
#' # If a larger static model is being run, the DBBD method leverages
#' # parallel processing capacities in most modern computers although
#' # these solution methods are slightly less robust than LU. In a 12
#' # CPU computer for example, 6-8 tasks is easily handled.
#'
#' # Standard
#'
#' # The primary options within this function are whether to run
#' # the solver in serial or parallel, what solution method to use,
#'
#'
#'
#'}
#' @return File path to a CMF file necessary to execute
#'   [`teems_parse()`].
#'
#' @export
ems_solve <- function(cmf_path = NULL,
                      n_tasks = 1L,
                      n_subintervals = 1L,
                      matrix_method = c("LU", "DBBD", "SBBD", "NDBBD"),
                      solution_method = c("Johansen", "mod_midpoint"),
                      steps = c(2L, 4L, 8L),
                      laA = 300L,
                      laD = 200L,
                      laDi = 500L,
                      terminal_run = FALSE,
                      suppress_outputs = FALSE,
                      ...)
{
  UseMethod("ems_solve")
}

#' @export
ems_solve.cmf <- function(cmf_path = NULL,
                          n_tasks = 1L,
                          n_subintervals = 1L,
                          matrix_method = c("LU", "DBBD", "SBBD", "NDBBD"),
                          solution_method = c("Johansen", "mod_midpoint"),
                          steps = c(2L, 4L, 8L),
                          laA = 300L,
                          laD = 200L,
                          laDi = 500L,
                          terminal_run = FALSE,
                          suppress_outputs = FALSE,
                          n_timesteps = NULL,
                          ...)
{
call <- match.call()
.check_docker(image_name = "teems",
              call = call)
timeID <- format(x = Sys.time(), "%H%M")
paths <- .get_solver_paths(cmf_path = cmf_path,
                           timeID = timeID,
                           call = call)
# n_timesteps can be carried as an attribute but better to deal with it in the solver
mod_arg <- .validate_solver_args(n_tasks = n_tasks,
                                 n_subintervals = n_subintervals,
                                 matrix_method = matrix_method,
                                 solution_method = solution_method,
                                 steps = steps,
                                 n_timesteps = n_timesteps,
                                 paths = paths,
                                 call = call)
cmds <- .construct_cmd(
  paths = paths,
  terminal_run = terminal_run,
  timeID = timeID,
  n_tasks = n_tasks,
  steps = steps,
  laA = laA,
  laDi = laDi,
  laD = laD,
  matsol = mod_arg$matsol,
  solmed = mod_arg$solmed,
  n_subintervals = mod_arg$n_subintervals,
  n_timesteps = mod_arg$n_timesteps,
  nesteddbbd = mod_arg$nesteddbbd,
  enable_time = mod_arg$enable_time
)
# need a process running in parallel, grepping output for error and then kill appropriate PID
if (isFALSE(cmds)) {return(invisible(NULL))}
elapsed_time <- system.time(system(cmds$solve))
.check_solver_log(elapsed_time = elapsed_time,
                  solve_cmd = cmds$solve,
                  paths = paths,
                  call = call)
system(cmds$sol_parse, ignore.stdout = TRUE)
if (!suppress_outputs) {
output <- .get_outputs(cmf_path = cmf_path)
return(output)
}
return(invisible(NULL))
}

#' @export
ems_solve.default <- function(cmf_path = NULL,
                              n_tasks = 1L,
                              n_subintervals = 1L,
                              matrix_method = c("LU", "DBBD", "SBBD", "NDBBD"),
                              solution_method = c("Johansen", "mod_midpoint"),
                              steps = c(2L, 4L, 8L),
                              laA = 300L,
                              laD = 200L,
                              laDi = 500L,
                              terminal_run = FALSE,
                              n_timesteps = NULL,
                              tab_file,
                              closure_file,
                              shock_file = NULL,
                              writeout = TRUE,
                              ...)
{
  browser()
  stop("work in progress")
  call <- match.call()
  if (missing(tab_file)) {.cli_missing(tab_file)}
  if (missing(closure_file)) {.cli_missing(closure_file)}
  if (missing(...)) {
    .cli_action(solve_err$missing_dots,
                action = "abort",
                call)
  }
  input_files <- list(...)
  cmf_path <- .execute_in_situ(input_files = input_files,
                               n_timesteps = n_timesteps,
                               tab_file = tab_file,
                               closure_file = closure_file,
                               shock_file = shock_file,
                               writeout = writeout,
                               call = call)
  #UseMethod("ems_solve")
}

#' Configure and solve model
#'
#' @description `teems_solve()` solves the constrained optimization
#'   problem according to a wide range of runtime configuration
#'   options. In order to solve, a `teems` Docker image must be
#'   prebuilt according to these specifications. Singularity,
#'   accuracy, and error checks are carried out following a successful
#'   run.
#'
#'   Learn more about this function including Tablo file limitations
#'   in `vignette("something")`
#'
#' @inheritParams teems_model
#' @inheritParams teems_closure
#' @inheritParams teems_deploy
#'
#' @param cmf_path Character length 1 (default is `NULL`), path to the
#'   cmf file generated by [`teems_deploy()`] or created via an
#'   "in-situ" run with [`teems_solve()`].
#' @param n_tasks Integer length 1 (default is `1L`), number of tasks
#'   to run in parallel. Must be `1L` if `"matrix_method"` == "LU".
#' @param n_subintervals Integer length 1 (default is `1L`), number of
#'   subintervals for the applied shock. More subintervals may
#'   alleviate accuracy issues stemming from large shock magnitudes.
#' @param matrix_method Character of length 1, matrix solution method
#'   (default is `"LU"`). Choices:
#'   * `"LU"`: Standard LU decomposition, the most robust and
#'   potentially slowest for a large model. `"n_tasks"` must be `1L`
#'   if `"matrix_method"` == "LU". For use with both static and
#'   dynamic models.
#'   * `"DBBD"`: Doubly bordered block diagonal, parallel solution
#'   method for static models. Potentially faster than `"LU"` although
#'   less robust.
#'   * `"SBBD"`: Singly bordered block diagonal, parallel solution
#'   method for intertemporal models. Potentially faster than `"LU"`
#'   although less robust.
#'   * `"NDBBD"`: Nested doubly bordered block diagonal, parallel
#'   solution method for large intertemporal models with many
#'   timesteps.
#' @param solution_method The solution method to be used, default is
#'   the "one-step" `"Johansen"`. Choices:
#'   * `"Johansen"`: The Johansen method is fast however it should
#'   only be used as a rough approximation due to handling of
#'   nonlinear equations. See:
#'   https://www.copsmodels.com/gpmanual.htm#gpd1.2.13
#'   * `"mod_midpoint"`: The modified midpoint method
#'   performs multiple passes. See:
#'   https://www.copsmodels.com/gpmanual.htm#gpd3.12.2
#' @param steps Integer length 3 (default is `c(2L, 4L, 8L)`). A
#'   vector of steps for the modified midpoint method, must be all odd
#'   or all even and length 3. Additional steps may improve accuracy
#'   for some model runs.
#' @param laA Integer length 1 (default is `300L`). The laA memory
#'   parameter for solver pertaining to matrix methods `"LU"` and
#'   `"SBBD"`. Value is in percentages. Increase gradually if prompted
#'   via "Error return from MA48B/BD because LA is ..."
#' @param laD Integer length 1 (default is `200L`). The laD memory
#'   parameter for solver pertaining to matrix methods `"DBBD"` and
#'   `"NDBBD"`. Value is in percentages. Increase gradually if
#'   prompted via "Error return from MA48B/BD because LA is ..."
#' @param laDi Integer length 1 (default is `500L`). The laDi memory
#'   parameter for solver pertaining to matrix method `"NDBBD"`. Value
#' is in percentages. Increase gradually if prompted via "Error return
#' from MA48B/BD because LA is ..."
#' @param terminal_run Logical length 1 (default is `FALSE`). When
#'   `TRUE`, the function is exited without running the solver. This
#'   allows the user to close any R IDE or other programs prior to
#' running from the terminal.
#' @param docker_tag Character length 1 (default `"latest"`). Docker
#'   tag to specify the which Docker image is use.
#' @param ... A named list of input files necessary for an "in-situ"
#'   model run. Names must correspond to "File" statements within the
#'   model Tablo file. Elements correspond to file paths where these
#'   files are found. No checks or modifications are conducted on
#'   input files used in this manner. This mode does not support
#'   partial provision of input file -- all model defined input files
#'   as well as `"tab_file"`, `"closure_file"`, and `"shock_file"`
#'   are required for in-situ model runs.
#'
#'
#' @seealso [`teems_parse()`] for retrieving model results.
#'
#' @examples
#' \dontrun{
#' # See `vignette("something")` for examples and explanation
#' # A number of runtime options are available to solve the model.
#'
#' # sample static model setup
#' v6.2_cmf_path <- teems_deploy(model_config = v6.2_model_config,
#'                              base_config = v6.2_base_config,
#'                              param_config = v6.2_param_config,
#'                              set_config = v6.2_set_config,
#'                              closure_config = v6.2_closure_config,
#'                              verbose = TRUE)
#'
#' # The most simple solution is an LU Johansen with a single task:
#' teems_solve(cmf_path = v6.2_cmf_path,
#'             matrix_method = "LU",
#'             solution_method = "Johansen")
#'
#' # For most model runs however the modified midpoint method is
#' # preferred. If variable accuracy is unacceptable, increasing the
#' # number of subintervals and/or steps may improve accuracy. We
#' # recommend isolating any improvements through slight modifications
#' # to either subintervals or steps.
#'
#' # Standard model run with LU and modified midpoint:
#' teems_solve(cmf_path = v6.2_cmf_path,
#'             matrix_method = "LU",
#'             n_subintervals = 2,
#'             solution_method = "mod_midpoint",
#'             steps = c(2, 4, 8))
#'
#' # If a larger static model is being run, the DBBD method leverages
#' # parallel processing capacities in most modern computers although
#' # these solution methods are slightly less robust than LU. In a 12
#' # CPU computer for example, 6-8 tasks is easily handled.
#'
#' # Standard
#'
#' # The primary options within this function are whether to run
#' # the solver in serial or parallel, what solution method to use,
#'
#'
#'
#'}
#' @return File path to a CMF file necessary to execute
#'   [`teems_parse()`].
#'
#' @export
teems_solve <- function(cmf_path = NULL,
                        n_tasks = 1L,
                        n_subintervals = 1L,
                        matrix_method = c("LU", "DBBD", "SBBD", "NDBBD"),
                        solution_method = c("Johansen", "mod_midpoint"),
                        steps = c(2L, 4L, 8L),
                        laA = 300L,
                        laD = 200L,
                        laDi = 500L,
                        terminal_run = FALSE,
                        docker_tag = "latest",
                        tab_file = NULL,
                        closure_file = NULL,
                        shock_file = NULL,
                        in_situ_writeout = TRUE,
                        quiet = FALSE,
                        ...)
{
call <- match.call()
.check_docker(image_name = "teems",
              call = call)
cmf_path <- .execute_in_situ(... = ...,
                             tab_file = tab_file,
                             closure_file = closure_file,
                             shock_file = shock_file,
                             cmf_path = cmf_path,
                             in_situ_writeout = in_situ_writeout,
                             call = call,
                             quiet = quiet)
timeID <- format(x = Sys.time(), "%H%M")
paths <- .get_solver_paths(cmf_path = cmf_path,
                           timeID = timeID,
                           call = call)
mod_arg <- .check_solver_arg(n_tasks = n_tasks,
                             n_subintervals = n_subintervals,
                             matrix_method = matrix_method,
                             solution_method = solution_method,
                             steps = steps,
                             paths = paths,
                             call = call)
cmd <- .construct_cmd(paths = paths,
                      terminal_run = terminal_run,
                      docker_tag = docker_tag,
                      timeID = timeID,
                      n_tasks = n_tasks,
                      steps = steps,
                      laA = laA,
                      laDi = laDi,
                      laD = laD,
                      matsol = mod_arg[["matsol"]],
                      solmed = mod_arg[["solmed"]],
                      n_subintervals = mod_arg[["n_subintervals"]],
                      n_timesteps = mod_arg[["n_timesteps"]],
                      nesteddbbd = mod_arg[["nesteddbbd"]],
                      enable_time = mod_arg[["enable_time"]])
.solve_model(exec_cmd = cmd[["exec"]],
             sol_parse_cmd = cmd[["sol_parse"]],
             paths = paths,
             quiet = quiet)
return(invisible(NULL))
}

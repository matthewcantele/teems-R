#' Configure and solve model
#'
#' @description `teems_solve()` solves the constrained optimization
#'   problem according to a wide range of runtime configuration
#'   options. In order to solve, a `teems` Docker image must be
#'   prebuilt according to these specifications. Singularity,
#'   accuracy, and error checks are carried out following a successful
#'   run.
#'
#'   Learn more about this function including Tablo file limitations
#'   in `vignette("something")`
#'
#' @inheritParams teems_model
#' @inheritParams teems_closure
#' @inheritParams teems_deploy
#'
#' @param cmf_path Character length 1 (default is `NULL`), path to the
#'   cmf file generated by [`teems_deploy()`] or created via an
#'   "in-situ" run with [`teems_solve()`].
#' @param n_tasks Integer length 1 (default is `1L`), number of tasks
#'   to run in parallel. Must be `1L` if `"matrix_method"` == "LU".
#' @param n_subintervals Integer length 1 (default is `1L`), number of
#'   subintervals for the applied shock. More subintervals may
#'   alleviate accuracy issues stemming from large shock magnitudes.
#' @param matrix_method Character of length 1, matrix solution method
#'   (default is `"LU"`). Choices:
#'   * `"LU"`: Standard LU decomposition, the most robust and
#'   potentially slowest for a large model. `"n_tasks"` must be `1L`
#'   if `"matrix_method"` == "LU". For use with both static and
#'   dynamic models.
#'   * `"DBBD"`: Doubly bordered block diagonal, parallel solution
#'   method for static models. Potentially faster than `"LU"` although
#'   less robust.
#'   * `"SBBD"`: Singly bordered block diagonal, parallel solution
#'   method for intertemporal models. Potentially faster than `"LU"`
#'   although less robust.
#'   * `"NDBBD"`: Nested doubly bordered block diagonal, parallel
#'   solution method for large intertemporal models with many
#'   timesteps.
#' @param solution_method The solution method to be used, default is
#'   the "one-step" `"Johansen"`. Choices:
#'   * `"Johansen"`: The Johansen method is fast however it should
#'   only be used as a rough approximation due to handling of
#'   nonlinear equations. See:
#'   https://www.copsmodels.com/gpmanual.htm#gpd1.2.13
#'   * `"mod_midpoint"`: The modified midpoint method
#'   performs multiple passes. See:
#'   https://www.copsmodels.com/gpmanual.htm#gpd3.12.2
#' @param steps Integer length 3 (default is `c(2L, 4L, 8L)`). A
#'   vector of steps for the modified midpoint method, must be all odd
#'   or all even and length 3. Additional steps may improve accuracy
#'   for some model runs.
#' @param laA Integer length 1 (default is `300L`). The laA memory
#'   parameter for solver pertaining to matrix methods `"LU"` and
#'   `"SBBD"`. Value is in percentages. Increase gradually if prompted
#'   via "Error return from MA48B/BD because LA is ..."
#' @param laD Integer length 1 (default is `200L`). The laD memory
#'   parameter for solver pertaining to matrix methods `"DBBD"` and
#'   `"NDBBD"`. Value is in percentages. Increase gradually if
#'   prompted via "Error return from MA48B/BD because LA is ..."
#' @param laDi Integer length 1 (default is `500L`). The laDi memory
#'   parameter for solver pertaining to matrix method `"NDBBD"`. Value
#' is in percentages. Increase gradually if prompted via "Error return
#' from MA48B/BD because LA is ..."
#' @param terminal_run Logical length 1 (default is `FALSE`). When
#'   `TRUE`, the function is exited without running the solver. This
#'   allows the user to close any R IDE or other programs prior to
#' running from the terminal.
#' @param docker_tag Character length 1 (default `"latest"`). Docker
#'   tag to specify the which Docker image is use.
#' @param ... A named list of input files necessary for an "in-situ"
#'   model run. Names must correspond to "File" statements within the
#'   model Tablo file. Elements correspond to file paths where these
#'   files are found. No checks or modifications are conducted on
#'   input files used in this manner. This mode does not support
#'   partial provision of input file -- all model defined input files
#'   as well as `"tab_file"`, `"closure_file"`, and `"shock_file"`
#'   are required for in-situ model runs.
#'
#'
#' @seealso [`teems_parse()`] for retrieving model results.
#'
#' @examples
#' \dontrun{
#' # See `vignette("something")` for examples and explanation
#' # A number of runtime options are available to solve the model.
#'
#' # sample static model setup
#' v6.2_cmf_path <- teems_deploy(model_config = v6.2_model_config,
#'                              base_config = v6.2_base_config,
#'                              param_config = v6.2_param_config,
#'                              set_config = v6.2_set_config,
#'                              closure_config = v6.2_closure_config,
#'                              verbose = TRUE)
#'
#' # The most simple solution is an LU Johansen with a single task:
#' teems_solve(cmf_path = v6.2_cmf_path,
#'             matrix_method = "LU",
#'             solution_method = "Johansen")
#'
#' # For most model runs however the modified midpoint method is
#' # preferred. If variable accuracy is unacceptable, increasing the
#' # number of subintervals and/or steps may improve accuracy. We
#' # recommend isolating any improvements through slight modifications
#' # to either subintervals or steps.
#'
#' # Standard model run with LU and modified midpoint:
#' teems_solve(cmf_path = v6.2_cmf_path,
#'             matrix_method = "LU",
#'             n_subintervals = 2,
#'             solution_method = "mod_midpoint",
#'             steps = c(2, 4, 8))
#'
#' # If a larger static model is being run, the DBBD method leverages
#' # parallel processing capacities in most modern computers although
#' # these solution methods are slightly less robust than LU. In a 12
#' # CPU computer for example, 6-8 tasks is easily handled.
#'
#' # Standard
#'
#' # The primary options within this function are whether to run
#' # the solver in serial or parallel, what solution method to use,
#'
#'
#'
#'}
#' @return File path to a CMF file necessary to execute
#'   [`teems_parse()`].
#'
#' @export
teems_solve <- function(cmf_path = NULL,
                        n_tasks = 1L,
                        n_subintervals = 1L,
                        matrix_method = c("LU", "DBBD", "SBBD", "NDBBD"),
                        solution_method = c("Johansen", "mod_midpoint"),
                        steps = c(2L, 4L, 8L),
                        laA = 300L,
                        laD = 200L,
                        laDi = 500L,
                        terminal_run = FALSE,
                        docker_tag = "latest",
                        tab_file = NULL,
                        closure_file = NULL,
                        shock_file = NULL,
                        ...)
{
call <- match.call()
.check_docker(image_name = "teems",
              call = call)
if (!missing(x = ...)) {
  io_files <- list(...)
  cmf_path <- .write_cmf(tab_file = tab_file,
                         shock_file = shock_file,
                         closure_file = closure_file,
                         io_files = io_files,
                         in_situ = TRUE)[["cmf_path"]]
}
paths <- .get_solver_paths(cmf_path = cmf_path,
                           call = call)
browser()
stopifnot(all(is.numeric(x = n_tasks), n_tasks == as.integer(x = n_tasks)))
stopifnot(all(is.numeric(x = n_subintervals), n_subintervals == as.integer(x = n_subintervals)))
matrix_method <- match.arg(arg = matrix_method)
solution_method <- match.arg(arg = solution_method)
if (!(all(steps %% 2 == 0) || all(steps %% 2 == 1))) {
  stop("The 'n_subintervals' argument must contain all even numbers or all odd numbers.")
}
if (!all(is.numeric(steps), length(steps) == 3)) {
  stop("The argument must be a numeric vector of length 3.")
}

tab <- .cmf_retrieve(file = "tabfile",
                     cmf_path = cmf_path,
                     run_dir = run_dir)
if (any(grepl(pattern = "(intertemporal)", x = tab))) {
  enable_time <- TRUE
} else {
  enable_time <- FALSE
}
matsol <- switch(
  EXPR = matrix_method,
  "LU" = 0,
  "SBBD" = 1,
  "DBBD" = 2,
  "NDBBD" = 3
)
if (is.element(el = matsol, set = c("SBBD", "NDBBD")) && !enable_time) {
  stop(paste("Matrix solution method",
             matsol,
             "only applicable to intertemporal model runs."))
}
# check int compatibility with LU and DBBD

if (identical(x = matrix_method, y = "NDBBD")) {
nesteddbbd <- 1
time_data <- .cmf_retrieve(file = "INTDATA",
                           cmf_path = cmf_path,
                           run_dir = run_dir)
n_timesteps <- time_data[grep(pattern = "NTSP", x = time_data) + 1]
} else {
  nesteddbbd <- 0
}
if (identical(x = solution_method, y = "mod_midpoint")) {
  step1 <- steps[1]
  step2 <- steps[2]
  step3 <- steps[3]
  solmed <- "Mmid"
} else {
  solmed <- "Johansen"
  n_subintervals <- 1
}


docker_preamble <- paste(
  "docker run --rm --privileged --volume",
  paste0(run_dir, ":/home/launchpad"),
  paste0("teems", ":", docker_tag),
  "/bin/bash -c")
exec_preamble <- paste(
  docker_preamble,
  '"singularity exec --bind /home/launchpad /home/solver.sif /home/teems-solver/lib/mpi/bin/mpiexec',
  "-n", n_tasks,
  "/home/teems-solver/solver/hsl",
  "-cmdfile", docker_cmf_path)
docker_diagnostic_out <- file.path(docker_run_dir, "out", paste0("solver_out", "_", timeID, ".txt"))
solver_param <- paste(
  "-matsol", matsol,
  if (identical(x = solution_method, y = "mod_midpoint")) {
    paste("-step1", step1, "-step2", step2, "-step3", step3)
  },
  if (any(is.element(el = matsol, set = c(0, 2, 3)))) {
    paste("-regset", "REG")
  },
  if (enable_time) {
    "-enable_time"
  },
  "-nsubints", n_subintervals,
  "-solmed", solmed,
  "-nesteddbbd", nesteddbbd,
  if (identical(matrix_method, "NDBBD")) {
    paste('-ndbbd_bl_rank', n_timesteps)
  },
  "-presol", 1,
  "-laA", laA,
  "-laDi", laDi,
  "-laD", laD,
  paste0("-x OMP_NUM_THREADS=", 1),
  paste("-maxthreads", 1),
  "| tee",
    paste(docker_diagnostic_out, '&& chown -R 1000:1000', paste0(docker_run_dir, '"'))
)
exec <- paste(exec_preamble, solver_param)
if (terminal_run) {
  cat(exec, file = file.path(run_dir, "model_exec.txt"))
  message(paste("Run the following command at the terminal:\n",
             exec))
  return()
}
elapsed_time <- system.time(system(command = exec))
print(elapsed_time)
cat(exec, file = file.path(run_dir, "model_exec.txt"))
out_file <- readLines(con = diagnostic_out)
if (any(grepl(pattern = "Error", x = out_file))) {
error <- TRUE
} else {
error <- FALSE
}
if (any(grepl(pattern = "singular", x = out_file))) {
singularity <- TRUE
} else {
  singularity <- FALSE
}
if (!error && !singularity) {
sol_parse_cmd <- paste(sub(pattern = "--privileged ", replacement = "", x = docker_preamble),
                           '"make -C /home/sol_parser && chown -R 1000:1000 /home/launchpad/out/variables/bin"')
system(command = sol_parse_cmd, ignore.stdout = TRUE)
}
diagnostics_out <- .run_diagnostics(out_file, error, singularity)
cat(diagnostics_out, "\n")
cmf_path
}

#' Loads and execute model-specifc `targets` pipeline
#'
#' @description `ems_deploy()` creates and executes a
#'   [`targets`](https://books.ropensci.org/targets/) pipeline for all
#'   loaded specifications according to their various path
#'   dependencies. Outputs from [`ems_model()`] and [`ems_load()`],
#'   are required inputs to
#'   `"model_config"`, `"load_config"` respectively.
#'
#'
#' @param model_config A list generated by the function
#'   [`ems_model()`].
#' @param model_name Character of length 1 (default is `"teems"`),
#'   descriptive model name. This string determines the name of
#'   model-specific directory to be written within `"base_dir"` as
#'   well as the `targets` pipeline file that will be run to generate
#'   all input files. Note that to access the `targets` store for a
#'   previously established model, both the `"model_name"` and
#'   `"base_dir"` must remain constant.
#' @param base_dir Character of length 1 (default is `tempdir()`),
#'   directory where the model-specific directory and model pipeline
#'   will be written. If `tempdir()`, the `targets` store and other
#'   model-specific files and directories will not persist across R
#'   sessions. If a persistent directory is specified, some targets
#'   will not need to be rerun in successive R sessions.
#' @param .testing Logical of length 1 (default is `FALSE`), developer
#'   option. If `TRUE`, [`targets::tar_make()`] will be called with
#'   `"callr_function = NULL"`. This allows the model pipeline to be
#'   halted for debugging and/or development purposes through
#'   placement of `browser()`.
#'
#' @return File path to a CMF file necessary to execute
#'   [`ems_solve()`].
#'
#' @details `ems_deploy()` consolidates all user inputs and carries
#'   out all operations necessary to run a CGE model. The output file
#'   path serves as a required input to [`ems_solve()`].
#'
#' @seealso [`ems_model()`] for generating the input to
#'   `"model"`.
#' @seealso [`ems_solve()`] for loading the output of this function.
#'
#' @examples
#' \dontrun{
#' # Ephemeral store and model inputs (written to a temporary directory):
#' ems_deploy(model_config = model_specs,
#'            load_config = load_specs,
#'            model_name = "my_temp_model")
#'
#' # Persistent store and model inputs
#' ems_deploy(model_config = model_specs,
#'            load_config = load_specs,
#'            model_name = "my_persistent_model",
#'            base_dir = "~")
#' 
#' # Multiple models can be retained by varying `base_dir` and/or
#' # `model_name`
#' ems_deploy(model_config = model_specs,
#'            load_config = load_specs,
#'            model_name = "my_second_persistent_model",
#'            base_dir = "~")
#'            
#' # Any pipeline object can be inspected using 
#' # [`targets::tar_read()`]. For example, the final model closure:
#' targets::tar_read(name = final.closure,
#'                   store = "store/path/in/diagnostic/output")
#' }
#' @export
ems_deploy <- function(data,
                       model,
                       write_dir = tools::R_user_dir("teems", "cache"),
                       shock = NULL,
                       closure_file = NULL,
                       swap_in = NULL,
                       swap_out = NULL,
                       shock_file = NULL) {
  if (missing(data)) {
    .cli_missing(data)
  }
  if (missing(model)) {
    .cli_missing(model)
  }
  call <- match.call()
  args_list <- mget(x = names(x = formals()))
  metadata <- attr(data, "metadata")
  attr(metadata, "file") <- "metadata.rds"
  sets <- .finalize_sets(
    sets = data[purrr::map_lgl(data, inherits, "set")],
    set_extract = subset(model, type == "Set"),
    time_steps = attr(data, "time_steps"),
    reference_year = metadata$reference_year,
    call = call,
    data_call = attr(data, "call")
  )
  v <- .validate_deploy_args(
    a = args_list,
    sets = sets,
    call = call
  )
  closure <- .validate_closure(
    closure = v$closure,
    sets = sets,
    var_extract = subset(model, type == "Variable"),
    call = call
  )
  closure <- .finalize_closure(
    swap_in = v$swap_in,
    swap_out = v$swap_out,
    closure = closure,
    sets = sets,
    var_extract = subset(model, type == "Variable"),
    model_name = attr(model, "tab_file"),
    call = call
  )
  if (!is.null(v$shock)) {
    shocks <- .finalize_shocks(
      shock = v$shock,
      shock_file = v$shock_file,
      closure = closure,
      sets = sets,
      var_extract = subset(model, type == "Variable")
    )
  } else {
    shocks <- structure(NA,
                        file = "null_shock.shf",
                        class = c("shock", class(NA)))
  }
  data <- .finalize_data(
    data = data,
    sets = sets,
    model = model,
    write_dir = write_dir,
    call = call
  )
  tab <- .finalize_tab(model = model)
  cmf <- .finalize_cmf(
    model = model,
    shock_file = attr(shocks, "file"),
    write_dir = v$write_dir
  )
  tab_path <- .ems_write(
    input = tab,
    write_dir = v$write_dir
  )
  closure_path <- .ems_write(
    input = closure,
    write_dir = v$write_dir
  )
  shock_path <- .ems_write(
    input = shocks,
    write_dir = v$write_dir
  )
  cmf_path <- .ems_write(input = cmf)
  attr(cmf_path, "tab_path") <- tab_path
  data_path <- lapply(data,
    .ems_write,
    write_dir = v$write_dir
  )
  dir.create(file.path(v$write_dir, "out", "sets"),
    recursive = TRUE
  )
  dir.create(file.path(v$write_dir, "out", "coefficients"),
    recursive = TRUE
  )
  dir.create(file.path(v$write_dir, "out", "variables", "bin"),
    recursive = TRUE
  )
  .diagnostic_output(
    tab_path = tab_path,
    cmf_path = cmf_path,
    closure_path = closure_path,
    shock_path = shock_path,
    data_path = unique(data_path),
    sets = sets,
    closure = closure,
    shocks = v$shock,
    metadata = metadata
  )
  cmf_path
}

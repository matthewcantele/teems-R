#' `r lifecycle::badge("experimental")`
#' Loads and execute model-specifc `targets` pipeline
#'
#' @description `ems_deploy()` creates and executes a
#'   [`targets`](https://books.ropensci.org/targets/) pipeline for all
#'   loaded specifications according to their various path
#'   dependencies. Outputs from [`ems_model()`] and [`ems_load()`],
#'   are required inputs to
#'   `"model_config"`, `"load_config"` respectively.
#'
#'
#' @param model_config A list generated by the function
#'   [`ems_model()`].
#' @param load_config A list generated by the function
#'   [`ems_load()`].
#' @param model_name Character of length 1 (default is `"teems"`),
#'   descriptive model name. This string determines the name of
#'   model-specific directory to be written within `"base_dir"` as
#'   well as the `targets` pipeline file that will be run to generate
#'   all input files. Note that to access the `targets` store for a
#'   previously established model, both the `"model_name"` and
#'   `"base_dir"` must remain constant.
#' @param base_dir Character of length 1 (default is `tempdir()`),
#'   directory where the model-specific directory and model pipeline
#'   will be written. If `tempdir()`, the `targets` store and other
#'   model-specific files and directories will not persist across R
#'   sessions. If a persistent directory is specified, some targets
#'   will not need to be rerun in successive R sessions.
#' @param .testing Logical of length 1 (default is `FALSE`), developer
#'   option. If `TRUE`, [`targets::tar_make()`] will be called with
#'   `"callr_function = NULL"`. This allows the model pipeline to be
#'   halted for debugging and/or development purposes through
#'   placement of `browser()`.
#'
#' @return File path to a CMF file necessary to execute
#'   [`ems_solve()`].
#'
#' @details `ems_deploy()` consolidates all user inputs and carries
#'   out all operations necessary to run a CGE model. The output file
#'   path serves as a required input to [`ems_solve()`].
#'
#' @seealso [`ems_model()`] for generating the input to
#'   `"model_config"`.
#' @seealso [`ems_load()`] for generating the input to
#'   `"base_config"`.
#' @seealso [`ems_solve()`] for loading the output of this function.
#'
#' @examples
#' \dontrun{
#' # Ephemeral store and model inputs (written to a temporary directory):
#' ems_deploy(model_config = model_specs,
#'            load_config = load_specs,
#'            model_name = "my_temp_model")
#'
#' # Persistent store and model inputs
#' ems_deploy(model_config = model_specs,
#'            load_config = load_specs,
#'            model_name = "my_persistent_model",
#'            base_dir = "~")
#' 
#' # Multiple models can be retained by varying `base_dir` and/or
#' # `model_name`
#' ems_deploy(model_config = model_specs,
#'            load_config = load_specs,
#'            model_name = "my_second_persistent_model",
#'            base_dir = "~")
#'            
#' # Any pipeline object can be inspected using 
#' # [`targets::tar_read()`]. For example, the final model closure:
#' targets::tar_read(name = final.closure,
#'                   store = "store/path/in/diagnostic/output")
#' }
#' @export
ems_deploy <- function(model_config,
                       load_config,
                       model_name = "teems",
                       base_dir,
                       .testing = FALSE)
{
if (missing(model_config)) {.cli_missing(model_config)}
if (missing(load_config)) {.cli_missing(load_config)}
if (missing(base_dir)) {base_dir <- tools::R_user_dir("teems", "data")}
call <- match.call()
args_list <- mget(x = names(x = formals()))
# check for missing arguments here (across inputs)
teems_paths <- .path_ledger(base_dir = base_dir,
                            model_name = model_name,
                            call)
# int_data <- .get_int_data(aux_data = data_specs[["aux_input"]],
#                           intertemporal = model_specs[["intertemporal"]])
targets <- .write_pipeline(model_config = model_config,
                           load_config = load_config,
                           model_name = model_name,
                           set_map_files = set_map_files,
                           metadata = load_config$metadata,
                           teems_paths = teems_paths)
call_hash_tbl <- .hash_table(model_config = model_config,
                             load_config = load_config)
.execute_pipeline(teems_paths = teems_paths,
                  call_hash_tbl = call_hash_tbl,
                  #tar_load_everything = tar_load_everything,
                  .testing = .testing)
# if (tar_load_everything) {
#   targets::tar_load_everything(store = teems_paths[["store"]],
#                                envir = .GlobalEnv)
# }
coefficient_names <- .process_tablo(tab_file = model_specs[["tab_file"]],
                                    type = "coefficient")[["coefficient"]]
gen_out <- .write_cmf(model_name = model_name,
                      coefficient_names = coefficient_names,
                      model_dir = teems_paths[["model"]],
                      store_dir = teems_paths[["store"]],
                      launchpad_dir = teems_paths[["launchpad"]])
cmf_path <- gen_out[["cmf_path"]]
if (model_specs$intertemporal) {
n_timesteps <- as.integer(purrr::pluck(targets::tar_read(data_array,
                                              store = teems_paths[["store"]]),
                            .o_n_timestep_header(),
                            "data"))
attr(cmf_path, "n_timesteps") <- n_timesteps
}
class(cmf_path) <- "cmf"
.pipeline_diagnostics(model_dir = teems_paths[["model"]],
                      launchpad_dir = teems_paths[["launchpad"]],
                      model_name = model_name,
                      metadata = load_specs[["metadata"]],
                      store_dir = teems_paths[["store"]],
                      io_files = gen_out[["io_files"]])
cmf_path
}

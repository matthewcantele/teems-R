#' Build and Export Tibble with Metadata
#'
#' This function constructs a tibble from input data, including metadata, and
#' optionally exports it to a file. It supports different data types and
#' formats, handling metadata accordingly, and can export the data in TSV, CSV,
#' or RDS format.
#'
#' @inheritParams teems_base
#'
#' @param ls_data A list containing data and metadata attributes generated by
#'   \code{.constructDT()}.
#' @note reference_year The base year used which corresponds to the GTAP data
#'   reference year chosen. Chronological year associated with t0 within dynamic
#'   model runs.
#'
#' @importFrom tibble as_tibble
#' @importFrom data.table rbindlist setkey
#' @return A tibble constructed from the input data and metadata.
#' @keywords internal
#' @noRd
.build_tibble <- function(ls_data,
                          preagg_header_replace) {

  data_type <- attr(x = ls_data, which = "data_type")

  # header_replace if != NULL
  if (!is.null(x = preagg_header_replace)) {
    for (header in seq_along(preagg_header_replace)) {

      new_header <- preagg_header_replace[header]
      header_name <- names(x = new_header)

      # check that file exists
      if (!file.exists(new_header)) {
        stop(paste("File with header replacement data for header:",
                   header_name,
                   "not found."))
      }

      # load file
      new_header_data <- data.table::fread(input = new_header)

      if (!is.element(el = "Value", set = colnames(x = new_header_data))) {
        stop(paste(dQuote(x = "Value"),
                   "column missing from the pre-agg header:",
                   header_name))
      }

      # load data to be replaced
      old_header_data <- purrr::pluck(.x = ls_data, header_name, "dt")

      # check that datasets are equal
      if (!isTRUE(x = all.equal(
        current = old_header_data[, !"Value"],
        target = new_header_data[, !"Value"],
        ignore.row.order = TRUE,
        ignore.col.order = TRUE
      ))) {
        stop(paste("One or more columns and/or rows in the new pre-agg header data for:",
                   header_name,
                   "is inconsistent or missing."))
      }

      # replace data
      purrr::pluck(.x = ls_data, header_name, "dt") <- new_header_data
    }
  }

  # create and write out metadata file
  metadata <- data.table::rbindlist(l = lapply(X = ls_data, FUN = function(header) {
    if (!identical(x = data_type, y = "set")) {
      list(
        header = header[["header_name"]],
        information = header[["information"]],
        coeff = header[["coefficient"]]
      )
    } else {
      list(
        header = header[["header_name"]],
        information = header[["information"]]
      )
    }
  }))

  # har file specific value type for headers (e.g., monetary, elasticity)
  # below will need revising for generalizability (pass in as separate parameter value target)
  if (identical(x = data_type, y = "dat")) {
    metadata[, let(v_class = "quantity")]
  } else if (identical(x = data_type, y = "par")) {
    metadata[is.element(el = header, set = c("ESBD", "ESBM", "ESBT", "ESBV")), let(v_class = "CES")]
    #metadata[is.element(el = header, set = c("ETA", "ETRE", "ETL1", "ETL2", "ETL3")), let(v_class = "CET")]
    metadata[is.element(el = header, set = c("ETA", "ETRE")), let(v_class = "CET")]
    metadata[is.element(el = header, set = c("INCP", "SUBP")), let(v_class = "CDE")]
    # metadata[is.element(el = header, set = c("YDEL")), let(v_class = "YEL")]
    metadata[is.element(el = header, set = c("RDLT")), let(v_class = "switch")]
    # metadata[is.element(el = header, set = c("SLUG")), v_class := "switch"]
    metadata[is.na(x = v_class), let(v_class = "other")]
    # metadata[is.element(el = header, set = c('SLUG', 'RDLT')), v_class := 'switch']
  }

  # convert to tibble
  tib_data <- tibble::as_tibble(x = metadata)

  # add attributes
  attr(x = tib_data, which = "data_type") <- data_type

  # join metadata with data (match unnecessary but to be safe...)
  r_idx <- match(x = names(x = ls_data), table = tib_data[["header"]])

  # check metadata/data match
  if (any(is.na(x = r_idx))) {
    stop("NA found in match between metadata and data")
  }

  tib_data[["dt"]] <- lapply(X = ls_data, FUN = function(d) {d[["dt"]]})

  # check for mismatches
  if (!all(is.element(el = names(x = tib_data[["dt"]]),
                     set = tib_data[["header"]]))) {
    stop("Name mismatch after metadata/data merge")
  }

  # names for later
  names(x = tib_data[["information"]]) <- tib_data[["header"]]

  if (!identical(x = data_type, y = "set")) {
    names(x = tib_data[["v_class"]]) <- tib_data[["header"]]
  }

  # sort data
  lapply(X = tib_data[["dt"]], FUN = data.table::setkey)

  return(tib_data)
}
